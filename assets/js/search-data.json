{
  "0": {
    "id": "0",
    "title": "Page not found",
    "content": "Page not foundThe page you requested could not be found. Try using the navigation or search to find what you're looking for or go to this site's home page.Check out these features                                Custom queries                            Table joins                                                                                                                            Transactions                            Migrations                                                    Web support            Or these in-depth guides                                                                                                                                                                                                                    Getting started                                            Writing queries                                                                                    Modularity with DAOs                                                                ",
    "url": "https://moor.simonbinder.eu/404",
    "relUrl": "/404"
  },
  "1": {
    "id": "1",
    "title": "Custom queries",
    "content": "Custom statementsAltough moor includes a fluent api that can be used to model most statements, advancedfeatures like GROUP BY statements or window functions are not yet supported. You canuse these features with custom statements. You don’t have to miss out on other benefitsmoor brings, though: Parsing the rows and query-streams also work on custom statements.Statements with a generated apiStarting from version 1.5, you can instruct moor to automatically generate a typesafeAPI for your select statements. At the moment, this feature is in an experimental statebut it can already handle most statements (select, update and delete). Of course,you can still write custom sql manually. See the sections below for details.To use this feature, all you need to is define your queries in your UseMoor annotation:@UseMoor(  tables: [Todos, Categories],  queries: {    'categoriesWithCount':        'SELECT *, (SELECT COUNT(*) FROM todos WHERE category = c.id) AS &quot;amount&quot; FROM categories c;'  },)class MyDatabase extends _$MyDatabase {  // rest of class stays the same}After running the build step again, moor will have written the CategoriesWithCountResult class for you -it will hold the result of your query. Also, the _$MyDatabase class from which you inherit will have themethods categoriesWithCount (which runs the query once) and watchCategoriesWithCount (which returnsan auto-updating stream).Queries can have parameters in them by using the ? or :name syntax. When your queries contain parameters,moor will figure out an appropriate type for them and include them in the generated methods. For instance,'categoryById': 'SELECT * FROM categories WHERE id = :id' will generate the method categoryById(int id).You can also use UPDATE or DELETE statements here. Of course, this feature is also available for daos,and it perfectly integrates with auto-updating streams by analyzing what tables you’re reading from orwriting to.Custom select statementsYou can issue custom queries by calling customSelect for a one-time query orcustomSelectStream for a query stream that automatically emits a new set of items whenthe underlying data changes. Using the todo example introduced in the getting started guide, we canwrite this query which will load the amount of todo entries in each category:class CategoryWithCount {  final Category category;  final int count; // amount of entries in this category  CategoryWithCount(this.category, this.count);}// then, in the database class:Stream&amp;lt;List&amp;lt;CategoryWithCount&amp;gt;&amp;gt; categoriesWithCount() {    // select all categories and load how many associated entries there are for    // each category    return customSelectStream(      'SELECT *, (SELECT COUNT(*) FROM todos WHERE category = c.id) AS &quot;amount&quot; FROM categories c;',      readsFrom: {todos, categories}, // used for the stream: the stream will update when either table changes      ).map((rows) {        // we get list of rows here. We just have to turn the raw data from the row into a        // CategoryWithCount. As we defined the Category table earlier, moor knows how to parse        // a category. The only thing left to do manually is extracting the amount        return rows          .map((row) =&amp;gt; CategoryWithCount(Category.fromData(row.data, this), row.readInt('amount')))          .toList();    });  }For custom selects, you should use the readsFrom parameter to specify from which tables the query isreading. When using a Stream, moor will be able to know after which updates the stream should emititems.Custom update statementsFor update and delete statements, you can use customUpdate. Just like customSelect, that methodalso takes a sql statement and optional variables. You can also tell moor which tables will beaffected by your query using the optional updates parameter. That will help with other selectstreams, which will then update automatically.",
    "url": "https://moor.simonbinder.eu/queries/custom",
    "relUrl": "/queries/custom"
  },
  "2": {
    "id": "2",
    "title": "Modularity with DAOs",
    "content": "Extracting functionality with DAOsWhen you have a lot of queries, putting them all into one class might becometedious. You can avoid this by extracting some queries into classes that are available from your main database class. Consider the following code:part 'todos_dao.g.dart';// the _TodosDaoMixin will be created by moor. It contains all the necessary// fields for the tables. The &amp;lt;MyDatabase&amp;gt; type annotation is the database class// that should use this dao.@UseDao(tables: [Todos])class TodosDao extends DatabaseAccessor&amp;lt;MyDatabase&amp;gt; with _$TodosDaoMixin {  // this constructor is required so that the main database can create an instance  // of this object.  TodosDao(MyDatabase db) : super(db);  Stream&amp;lt;List&amp;lt;TodoEntry&amp;gt;&amp;gt; todosInCategory(Category category) {    if (category == null) {      return (select(todos)..where((t) =&amp;gt; isNull(t.category))).watch();    } else {      return (select(todos)..where((t) =&amp;gt; t.category.equals(category.id)))          .watch();    }  }}If we now change the annotation on the MyDatabase class to @UseMoor(tables: [Todos, Categories], daos: [TodosDao])and re-run the code generation, a generated getter todosDao can be used to access the instance of that dao.",
    "url": "https://moor.simonbinder.eu/daos/",
    "relUrl": "/daos/"
  },
  "3": {
    "id": "3",
    "title": "Frequently asked questions",
    "content": "Using the databaseIf you’ve created a MyDatabase class by following the getting started guide, youstill need to somehow obtain an instance of it. It’s recommended to only have one (singleton) instance of your database,so you could store that instance in a global variable:Vanilla flutterMyDatabase database;void main() {  database = MyDatabase();  runApp(MyFlutterApp());}It would be cleaner to use InheritedWidgets for that, and the provider package helps here:ProviderIf you’re using the provider package, you can wrap your top-level widget in aprovider that manages the database instance:void main() {  runApp(    Provider&amp;lt;MyDatabase&amp;gt;(      builder: (context) =&amp;gt; MyDatabase(),      child: MyFlutterApp(),   ),  );}Your widgets would then have access to the database using Provider.of&amp;lt;MyDatabase&amp;gt;(context).A more complex architectureIf you’re strict on keeping your business logic out of the widget layer, you probably use some dependency injection framework like kiwi or get_it to instantiate services and view models. Creating a singleton instance of MyDatabasein your favorite dependency injection framework for flutter hence solves this problem for you.",
    "url": "https://moor.simonbinder.eu/faq/",
    "relUrl": "/faq/"
  },
  "4": {
    "id": "4",
    "title": "Getting started",
    "content": "Getting startedNote: If you prefer a tutorial video, Reso Coder has made a detailed video explaininghow to get started. You can watch it here.Adding the dependencyFirst, let’s add moor to your project’s pubspec.yaml.At the moment, the current version of moor_flutter is  and the current version of moor_generator is dependencies:  moor_flutter: # use the latest versiondev_dependencies:  moor_generator: # use the latest version  build_runner: We’re going to use the moor_flutter library to specify tables and access the database. Themoor_generator library will take care of generating the necessary code so thelibrary knows what your table structure looks like.Declaring tablesUsing moor, you can model the structure of your tables with simple dart code:import 'package:moor_flutter/moor_flutter.dart';// assuming that your file is called filename.dart. This will give an error at first,// but it's needed for moor to know about the generated codepart 'filename.g.dart'; // this will generate a table called &quot;todos&quot; for us. The rows of that table will// be represented by a class called &quot;Todo&quot;.class Todos extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get title =&amp;gt; text().withLength(min: 6, max: 32)();  TextColumn get content =&amp;gt; text().named('body')();  IntColumn get category =&amp;gt; integer().nullable()();}// This will make moor generate a class called &quot;Category&quot; to represent a row in this table.// By default, &quot;Categorie&quot; would have been used because it only strips away the trailing &quot;s&quot;// in the table name.@DataClassName(&quot;Category&quot;)class Categories extends Table {    IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get description =&amp;gt; text()();}// this annotation tells moor to prepare a database class that uses both of the// tables we just defined. We'll see how to use that database class in a moment.@UseMoor(tables: [Todos, Categories])class MyDatabase {  }⚠️ Note: The column definitions, the table name and the primary key must be known atcompile time. For column definitions and the primary key, the function must use the =&amp;gt;operator and can’t contain anything more than what’s included in the documentation and theexamples. Otherwise, the generator won’t be able to know what’s going on.Generating the codeMoor integrates with Dart’s build system, so you can generate all the code needed with flutter packages pub run build_runner build. If you want to continously rebuild the generated codewhever you change your code, run flutter packages pub run build_runner watch instead.After running either command once, the moor generator will have created a class for yourdatabase and data classes for your entities. To use it, change the MyDatabase class asfollows:@UseMoor(tables: [Todos, Categories])class MyDatabase extends _$MyDatabase {  // we tell the database where to store the data with this constructor  MyDatabase() : super(FlutterQueryExecutor.inDatabaseFolder(path: 'db.sqlite'));  // you should bump this number whenever you change or add a table definition. Migrations  // are covered later in this readme.  @override  int get schemaVersion =&amp;gt; 1; }Congratulations, you now have a class which you can use to easily write queries.A detailed guide on how to do that in Dart is written here.If you prefer to write SQL and have moor generate the mapping out, check outcustom queriesPS: You might be asking how you would actually obtain an instance of MyDatabase foryour widgets. If so, here is some guidance.",
    "url": "https://moor.simonbinder.eu/getting-started/",
    "relUrl": "/getting-started/"
  },
  "5": {
    "id": "5",
    "title": "Home",
    "content": "MoorMoor is an easy to use, reactive persistence library for Flutter apps. Define yourdatabase tables in pure Dart and enjoy a fluent query API, auto-updating streamsand more!Get started nowView on GitHubFeaturesMoor contains a whole set of features that makes working with persistence much easier and safer.Declarative tablesWith moor, you can declare your tables in pure dart without having to miss out on advanced sqlitefeatures. Moor will take care of writing the CREATE TABLE statements when the database is created.Fluent queriesThanks to the power of Dart build system, moor will let you write typesafe queries:Future&amp;lt;User&amp;gt; userById(int id) {    return (select(users)..where((user) =&amp;gt; user.id.equals(id))).getSingle();    // runs SELECT * FROM users WHERE id = ?, automatically binds the parameter    // and parses the result row.}No more hard to debug typos in sql, no more annoying to write mapping code - moor takescare of all the boring parts.Prefer SQL? Moor got you coveredMoor contains a powerful sql parser and analyzer, allowing it to create typesafe APIs forall your sql queries:@UseMoor(  tables: [Categories],  queries: {    'categoryById': 'SELECT * FROM categories WHERE id = :id'  },)class MyDatabase extends _$MyDatabase {// the _$MyDatabase class will have the categoryById(int id) and watchCategoryById(int id)// methods that execute the sql and parse its result into a generated class.All queries are validated and analyzed during build-time, so that moor can provide hintsabout potential errors quickly and generate efficient mapping code once.Auto-updating streamsFor all your queries, moor can generate a Stream that will automatically emit new resultswhenever the underlying data changes. This is first-class feature that perfectly integrateswith custom queries, daos and all the other features. Having an auto-updating single sourceof truth makes managing perstistent state much easier!And much moor…Moor also supports transactions, DAOs, powerful helpers for migrations, batched inserts andmany more features that makes writing persistence code much easier.Getting startedAdding the dependencyFirst, let’s add moor to your project’s pubspec.yaml.At the moment, the current version of moor_flutter is  and the current version of moor_generator is dependencies:  moor_flutter: # use the latest versiondev_dependencies:  moor_generator: # use the latest version  build_runner: We’re going to use the moor_flutter library to specify tables and access the database. Themoor_generator library will take care of generating the necessary code so thelibrary knows what your table structure looks like.Declaring tablesUsing moor, you can model the structure of your tables with simple dart code:import 'package:moor_flutter/moor_flutter.dart';// assuming that your file is called filename.dart. This will give an error at first,// but it's needed for moor to know about the generated codepart 'filename.g.dart'; // this will generate a table called &quot;todos&quot; for us. The rows of that table will// be represented by a class called &quot;Todo&quot;.class Todos extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get title =&amp;gt; text().withLength(min: 6, max: 32)();  TextColumn get content =&amp;gt; text().named('body')();  IntColumn get category =&amp;gt; integer().nullable()();}// This will make moor generate a class called &quot;Category&quot; to represent a row in this table.// By default, &quot;Categorie&quot; would have been used because it only strips away the trailing &quot;s&quot;// in the table name.@DataClassName(&quot;Category&quot;)class Categories extends Table {    IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get description =&amp;gt; text()();}// this annotation tells moor to prepare a database class that uses both of the// tables we just defined. We'll see how to use that database class in a moment.@UseMoor(tables: [Todos, Categories])class MyDatabase {  }⚠️ Note: The column definitions, the table name and the primary key must be known atcompile time. For column definitions and the primary key, the function must use the =&amp;gt;operator and can’t contain anything more than what’s included in the documentation and theexamples. Otherwise, the generator won’t be able to know what’s going on.Generating the codeMoor integrates with Dart’s build system, so you can generate all the code needed with flutter packages pub run build_runner build. If you want to continously rebuild the generated codewhever you change your code, run flutter packages pub run build_runner watch instead.After running either command once, the moor generator will have created a class for yourdatabase and data classes for your entities. To use it, change the MyDatabase class asfollows:@UseMoor(tables: [Todos, Categories])class MyDatabase extends _$MyDatabase {  // we tell the database where to store the data with this constructor  MyDatabase() : super(FlutterQueryExecutor.inDatabaseFolder(path: 'db.sqlite'));  // you should bump this number whenever you change or add a table definition. Migrations  // are covered later in this readme.  @override  int get schemaVersion =&amp;gt; 1; }You can ignore the schemaVersion at the moment, the important part is that you cannow run your queries with fluent Dart codeWriting queries",
    "url": "https://moor.simonbinder.eu/",
    "relUrl": "/"
  },
  "6": {
    "id": "6",
    "title": "Table joins",
    "content": "JoinsMoor supports sql joins to write queries that operate on more than one table. To use that feature, starta select regular select statement with select(table) and then add a list of joins using .join(). Forinner and left outer joins, a ON expression needs to be specified. Here’s an example using the tablesdefined in the example.// we define a data class to contain both a todo entry and the associated categoryclass EntryWithCategory {  EntryWithCategory(this.entry, this.category);  final TodoEntry entry;  final Category category;}// in the database class, we can then load the category for each entryStream&amp;lt;List&amp;lt;EntryWithCategory&amp;gt;&amp;gt; entriesWithCategory() {  final query = select(todos).join([    leftOuterJoin(categories, categories.id.equalsExp(todos.category)),  ]);  // see next section on how to parse the result}Parsing resultsCalling get() or watch on a select statement with join returns a Future or Stream ofList&amp;lt;TypedResult&amp;gt; respectively. Each TypedResult represents a row from which data can be read. It contains a rawData getter to obtain the raw row. But more importantly, thereadTable method can be used to read a data class from a table.In the example query above, we can read the todo entry and the category from each row like this:return query.watch().map((rows) {  return rows.map((row) {    return EntryWithCategory(      row.readTable(todos),      row.readTable(categories),    );  }).toList();});Note: readTable returns null when an entity is not present in the row. For instance, todo entriesmight not be in any category. In that case, row.readTable(categories) returns null.AliasesSometimes, a query references a table more than once. Consider the following example to store saved routes for anavigation system:class GeoPoints extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get name =&amp;gt; text()();  TextColumn get latitude =&amp;gt; text()();  TextColumn get longitude =&amp;gt; text()();}class Routes extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get name =&amp;gt; text()();  // contains the id for the start and destination geopoint.  IntColumn get start =&amp;gt; integer()();  IntColumn get destination =&amp;gt; integer()();}Now, let’s say we wanted to also load the start and destination GeoPoint object for each route. We’d have to usea join on the geo-points table twice: For the start and destination point. To express that in a query, aliasescan be used:class RouteWithPoints {  final Route route;  final GeoPoint start;  final GeoPoint destination;  RouteWithPoints({this.route, this.start, this.destination});}// inside the database class:Future&amp;lt;List&amp;lt;RouteWithPoints&amp;gt;&amp;gt; loadRoutes() async {  // create aliases for the geoPoints table so that we can reference it twice  final start = alias(geoPoints, 's');  final destination = alias(geoPoints, 'd');   final rows = await select(routes).join([    innerJoin(start, start.id.equalsExp(routes.start)),    innerJoin(destination, destination.id.equalsExp(routes.destination)),  ]).get();  return rows.map((resultRow) {    return RouteWithPoints(      route: resultRow.readTable(routes),      start: resultRow.readTable(start),      destination: resultRow.readTable(destination),    );  }).toList();}The generated statement then looks like this:SELECT     routes.id, routes.name, routes.start, routes.destination,    s.id, s.name, s.latitude, s.longitude,    d.id, d.name, d.latitude, d.longitude FROM routes     INNER JOIN geo_points s ON s.id = routes.start    INNER JOIN geo_points d ON d.id = routes.destination",
    "url": "https://moor.simonbinder.eu/queries/joins",
    "relUrl": "/queries/joins"
  },
  "7": {
    "id": "7",
    "title": "Migrations",
    "content": "MigrationsMoor provides a migration API that can be used to gradually apply schema changes after bumpingthe schemaVersion getter inside the Database class. To use it, override the migrationgetter. Here’s an example: Let’s say you wanted to add a due date to your todo entries:class Todos extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get title =&amp;gt; text().withLength(min: 6, max: 10)();  TextColumn get content =&amp;gt; text().named('body')();  IntColumn get category =&amp;gt; integer().nullable()();  DateTimeColumn get dueDate =&amp;gt; dateTime().nullable()(); // new, added column}We can now change the database class like this:  @override  int get schemaVersion =&amp;gt; 2; // bump because the tables have changed  @override  MigrationStrategy get migration =&amp;gt; MigrationStrategy(    onCreate: (Migrator m) {      return m.createAllTables();    },    onUpgrade: (Migrator m, int from, int to) async {      if (from == 1) {        // we added the dueDate property in the change from version 1        await m.addColumn(todos, todos.dueDate);      }    }  );  // rest of class can stay the sameYou can also add individual tables or drop them - see the reference of Migratorfor all the available options. You can’t use the high-level query API in migrations - calling select or similar methods will throw.sqlite can feel a bit limiting when it comes to migrations - there only are methods to create tables and columns.Existing columns can’t be altered or removed. A workaround is described here, itcan be used together with issueCustomQueryto run the statements.Post-migration callbacksStarting from moor 1.5, you can use the beforeOpen parameter in the MigrationStrategy which will be called aftermigrations, but after any other queries are run. You could use it to populate data after the database has been created:beforeOpen: (db, details) async {    if (details.wasCreated) {      final workId = await db.into(categories).insert(Category(description: 'Work'));          await db.into(todos).insert(TodoEntry(            content: 'A first todo entry',            category: null,            targetDate: DateTime.now(),      ));          await db.into(todos).insert(            TodoEntry(              content: 'Rework persistence code',              category: workId,              targetDate: DateTime.now().add(const Duration(days: 4)),      ));    }},You could also activate pragma statements that you need:beforeOpen: (db, details) async {  if (details.wasCreated) {    // ...  }  await db.customStatement('PRAGMA foreign_keys = ON');}It is important that you run these queries on db explicitly. Failing to do so causes a deadlock which prevents thedatabase from being opened.",
    "url": "https://moor.simonbinder.eu/migrations/",
    "relUrl": "/migrations/"
  },
  "8": {
    "id": "8",
    "title": "Transactions",
    "content": "TransactionsMoor has support for transactions and allows multiple queries to run atomically.To begin a transaction, call the transaction method on your database or a DAO.It takes a function as an argument that will be run on the transaction. In thefollowing example, which deals with deleting a category, we move all todo entriesin that category back to the default category:Future deleteCategory(Category category) {  return transaction((t) async {    // first, move the affected todo entries back to the default category    await t.customUpdate(      'UPDATE todos SET category = NULL WHERE category = ?',      updates: {todos},      variables: [Variable.withInt(category.id)],    );    // then, delete the category    await t.delete(categories).delete(category);  });}⚠️ GotchasThere are a couple of things that should be kept in mind when working with transactions:  Await all calls: All queries inside the transaction must be await-ed. The transaction  will complete when the inner method completes. Without await, some queries might be operating  on the transaction after it has been closed!  Don’t run calls on your database: Inside a transaction function, all queries must  be on the transaction itself.    await transaction((t) async {  // BAD - this will run on the database itself!  await delete(categories).delete(category);});await transaction((t) async {  // GOOD!  await t.delete(categories).delete(category);});        The reason behind this is that no calls can operate on the database while it’s in a transaction,  they will run after the transaction has completed. When the completion of the transaction can only  happen after a call to the database completes, as in the fist example, the database will reach a  dead lock!  Transactions and query streamsQuery streams that have been created outside a transaction work nicely together withupdates made in a transaction: All changes to tables will only be reported after thetransaction completes. Updates inside a transaction don’t have an immediate effect onstreams.However, streams cannot be created inside transactions! The reason behind that decisionis that it’s unclear what should happen to the stream after the transaction completes.Should the stream complete as well? Begin to the updated data outside the transaction?To not make things confusing here, this is forbidden.",
    "url": "https://moor.simonbinder.eu/transactions",
    "relUrl": "/transactions"
  },
  "9": {
    "id": "9",
    "title": "Web support",
    "content": "Web supportStarting from moor 1.6, you can experimentally use moor in Dart webapps. Moor web supports Flutter Web, AngularDart, plain dart:html or any other web framework.Getting startedInstead of depending on moor_flutter, you need to depend on on moor directly. Apart from that, you canfollow the getting started guide.Also, instead of using a FlutterQueryExecutor in your database classes, you can use a WebDatabase executor:import 'package:moor/moor_web.dart';@UseMoor(tables: [Todos, Categories])class MyDatabase extends _$MyDatabase {  // here, &quot;app&quot; is the name of the database - you can choose any name you want  MyDatabase() : super(WebDatabase('app'));Moor web is built on top of the sql.js library, which you need to include:&amp;lt;!doctype html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt;    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;    &amp;lt;script defer src=&quot;sql-wasm.js&quot;&amp;gt;&amp;lt;/script&amp;gt;    &amp;lt;script defer src=&quot;main.dart.js&quot; type=&quot;application/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;You can grab the latest version of sql-wasm.js and sql-wasm.wasm hereand copy them into your web folder.Sharing code between native apps and webIf you want to share your database code between native applications and webapps, just import thebasic moor library and make the QueryExecutor configurable:// don't import moor_web.dart or moor_flutter/moor_flutter.dart in shared codeimport 'package:moor/moor.dart';@UseMoor(/* ... */)class SharedDatabase extends _$MyDatabase {    SharedDatabase(QueryExecutor e): super(e);}With native Flutter, you can create an instance of your database withimport 'package:moor_flutter/moor_flutter.dart';SharedDatabase constructDb() {    return SharedDatabase(FlutterQueryExecutor.inDatabaseFolder(path: 'db.sqlite'));}On the web, you can useimport 'package:moor/moor_web.dart';SharedDatabase constructDb() {    return SharedDatabase(WebDatabse('db'));}DebuggingYou can see all queries sent from moor to the underlying database engine by enabling the logStatementsparameter on the WebDatabase - they will appear in the console.When you have assertions enabled (e.g. in debug mode), moor will expose the underlying databaseobject via window.db. If you need to quickly run a query to check the state of the database, you can usedb.exec(sql).If you need to delete your databases, there stored using local storage. You can clear all your data with localStorage.clear().Web support is experimental at the moment, so please report all issues you find.",
    "url": "https://moor.simonbinder.eu/web",
    "relUrl": "/web"
  },
  "10": {
    "id": "10",
    "title": "Writing queries",
    "content": "Note: This assumes that you already have your database class ready. Follow the [instructions][getting-started] over here on how to do that.Writing queriesThe examples here use the tables defined [here][getting-started].For each table you’ve specified in the @UseMoor annotation on your database class,a corresponding getter for a table will be generated. That getter can be used torun statements:// inside the database class, the `todos` getter has been created by moor.// loads all todo entriesFuture&amp;lt;List&amp;lt;Todo&amp;gt;&amp;gt; get allTodoEntries =&amp;gt; select(todos).get();// watches all todo entries in a given category. The stream will automatically// emit new items whenever the underlying data changes.Stream&amp;lt;List&amp;lt;TodoEntry&amp;gt;&amp;gt; watchEntriesInCategory(Category c) {  return (select(todos)..where((t) =&amp;gt; t.category.equals(c.id))).watch();}Select statementsYou can create select statements by starting them with select(tableName), where the table nameis a field generated for you by moor. Each table used in a database will have a matching fieldto run queries against. Any query can be run once with get() or be turned into an auto-updatingstream using watch().WhereYou can apply filters to a query by calling where(). The where method takes a function thatshould map the given table to an Expression of boolean. A common way to create such expressionis by using equals on expressions. Integer columns can also be compared with isBiggerThanand isSmallerThan. You can compose expressions using and(a, b), or(a, b) and not(a).LimitYou can limit the amount of results returned by calling limit on queries. The method acceptsthe amount of rows to return and an optional offset.OrderingYou can use the orderBy method on the select statement. It expects a list of functions that extract the individualordering terms from the table.Future&amp;lt;List&amp;lt;TodoEntry&amp;gt;&amp;gt; sortEntriesAlphabetically() {  return (select(todos)..orderBy([(t) =&amp;gt; OrderingTerm(expression: t.title)])).get();}You can also reverse the order by setting the mode property of the OrderingTerm toOrderingMode.desc.Updates and deletesYou can use the generated classes to update individual fields of any row:Future moveImportantTasksIntoCategory(Category target) {  // for updates, we use the &quot;companion&quot; version of a generated class. This wraps the  // fields in a &quot;Value&quot; type which can be set to be absent using &quot;Value.absent()&quot;. This  // allows us to separate between &quot;SET category = NULL&quot; (`category: Value(null)`) and not  // updating the category at all: `category: Value.absent()`.  return (update(todos)      ..where((t) =&amp;gt; t.title.like('%Important%'))    ).write(TodosCompanion(      category: Value(target.id),    ),  );}Future update(TodoEntry entry) {  // using replace will update all fields from the entry that are not marked as a primary key.  // it will also make sure that only the entry with the same primary key will be updated.  // Here, this means that the row that has the same id as entry will be updated to reflect  // the entry's title, content and category. As it set's its where clause automatically, it  // can not be used together with where.  return update(todos).replace(entry);}Future feelingLazy() {  // delete the oldest nine tasks  return (delete(todos)..where((t) =&amp;gt; t.id.isSmallerThanValue(10))).go();}⚠️ Caution: If you don’t explicitly add a where clause on updates or deletes, the statement will affect all rows in the table!InsertsYou can very easily insert any valid object into tables:// returns the generated idFuture&amp;lt;int&amp;gt; addTodoEntry(TodosCompanion entry) {  return into(todos).insert(entry);}All row classes generated will have a constructor that can be used to create objects:addTodoEntry(  Todo(    title: 'Important task',    content: 'Refactor persistence code',  ),);If a column is nullable or has a default value (this includes auto-increments), the fieldcan be omitted. All other fields must be set and non-null. The insert method will throwotherwise.            [getting-started]: {{ site.common_links.getting_started      absolute_url }}      ",
    "url": "https://moor.simonbinder.eu/queries/",
    "relUrl": "/queries/"
  }
}
