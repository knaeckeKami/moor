{
  "0": {
    "id": "0",
    "title": "Page not found",
    "content": "Page not foundThe page you requested could not be found. Try using the navigation or search to find what you're looking for or go to this site's home page.Check out these features                                Custom queries                            Table joins                                                                                                    Transactions                            Migrations                        Or these in-depth guides                                                                                                                                                                            Getting started                                            Writing queries                                                                                    Modularity with DAOs                        ",
    "url": "https://moor.simonbinder.eu/404",
    "relUrl": "/404"
  },
  "1": {
    "id": "1",
    "title": "Custom queries",
    "content": "Custom statementsAltough moor includes a fluent api that can be used to model most statements, advancedfeatures like GROUP BY statements or window functions are not yet supported. You canuse these features with custom statements. You don’t have to miss out on other benefitsmoor brings, though: Parsing the rows and query-streams also work on custom statements.Custom select statementsYou can issue custom queries by calling customSelect for a one-time query orcustomSelectStream for a query stream that automatically emits a new set of items whenthe underlying data changes. Using the todo example introduced in the getting started guide, we canwrite this query which will load the amount of todo entries in each category:class CategoryWithCount {  final Category category;  final int count; // amount of entries in this category  CategoryWithCount(this.category, this.count);}// then, in the database class:Stream&amp;lt;List&amp;lt;CategoryWithCount&amp;gt;&amp;gt; categoriesWithCount() {    // select all categories and load how many associated entries there are for    // each category    return customSelectStream(      'SELECT *, (SELECT COUNT(*) FROM todos WHERE category = c.id) AS &quot;amount&quot; FROM categories c;',      readsFrom: {todos, categories}, // used for the stream: the stream will update when either table changes      ).map((rows) {        // we get list of rows here. We just have to turn the raw data from the row into a        // CategoryWithCount. As we defined the Category table earlier, moor knows how to parse        // a category. The only thing left to do manually is extracting the amount        return rows          .map((row) =&amp;gt; CategoryWithCount(Category.fromData(row.data, this), row.readInt('amount')))          .toList();    });  }For custom selects, you should use the readsFrom parameter to specify from which tables the query isreading. When using a Stream, moor will be able to know after which updates the stream should emititems.Custom update statementsFor update and delete statements, you can use customUpdate. Just like customSelect, that methodalso takes a sql statement and optional variables. You can also tell moor which tables will beaffected by your query using the optional updates parameter. That will help with other selectstreams, which will then update automatically.",
    "url": "https://moor.simonbinder.eu/queries/custom",
    "relUrl": "/queries/custom"
  },
  "2": {
    "id": "2",
    "title": "Modularity with DAOs",
    "content": "Extracting functionality with DAOsWhen you have a lot of queries, putting them all into one class might becometedious. You can avoid this by extracting some queries into classes that are available from your main database class. Consider the following code:part 'todos_dao.g.dart';// the _TodosDaoMixin will be created by moor. It contains all the necessary// fields for the tables. The &amp;lt;MyDatabase&amp;gt; type annotation is the database class// that should use this dao.@UseDao(tables: [Todos])class TodosDao extends DatabaseAccessor&amp;lt;MyDatabase&amp;gt; with _$TodosDaoMixin {  // this constructor is required so that the main database can create an instance  // of this object.  TodosDao(MyDatabase db) : super(db);  Stream&amp;lt;List&amp;lt;TodoEntry&amp;gt;&amp;gt; todosInCategory(Category category) {    if (category == null) {      return (select(todos)..where((t) =&amp;gt; isNull(t.category))).watch();    } else {      return (select(todos)..where((t) =&amp;gt; t.category.equals(category.id)))          .watch();    }  }}If we now change the annotation on the MyDatabase class to @UseMoor(tables: [Todos, Categories], daos: [TodosDao])and re-run the code generation, a generated getter todosDao can be used to access the instance of that dao.",
    "url": "https://moor.simonbinder.eu/daos/",
    "relUrl": "/daos/"
  },
  "3": {
    "id": "3",
    "title": "Getting started",
    "content": "Getting startedAdding the dependencyFirst, let’s add moor to your project’s pubspec.yaml.At the moment, the current version of moor_flutter is  and the current version of moor_generator is dependencies:  moor_flutter: # use the latest versiondev_dependencies:  moor_generator: # use the latest version  build_runner: We’re going to use the moor_flutter library to specify tables and access the database. Themoor_generator library will take care of generating the necessary code so thelibrary knows what your table structure looks like.Declaring tablesUsing moor, you can model the structure of your tables with simple dart code:import 'package:moor_flutter/moor_flutter.dart';// assuming that your file is called filename.dart. This will give an error at first,// but it's needed for moor to know about the generated codepart 'filename.g.dart'; // this will generate a table called &quot;todos&quot; for us. The rows of that table will// be represented by a class called &quot;Todo&quot;.class Todos extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get title =&amp;gt; text().withLength(min: 6, max: 32)();  TextColumn get content =&amp;gt; text().named('body')();  IntColumn get category =&amp;gt; integer().nullable()();}// This will make moor generate a class called &quot;Category&quot; to represent a row in this table.// By default, &quot;Categorie&quot; would have been used because it only strips away the trailing &quot;s&quot;// in the table name.@DataClassName(&quot;Category&quot;)class Categories extends Table {    IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get description =&amp;gt; text()();}// this annotation tells moor to prepare a database class that uses both of the// tables we just defined. We'll see how to use that database class in a moment.@UseMoor(tables: [Todos, Categories])class MyDatabase {  }⚠️ Note: The column definitions, the table name and the primary key must be known atcompile time. For column definitions and the primary key, the function must use the =&amp;gt;operator and can’t contain anything more than what’s included in the documentation and theexamples. Otherwise, the generator won’t be able to know what’s going on.Generating the codeMoor integrates with Dart’s build system, so you can generate all the code needed with flutter packages pub run build_runner build. If you want to continously rebuild the generated codewhever you change your code, run flutter packages pub run build_runner watch instead.After running either command once, the moor generator will have created a class for yourdatabase and data classes for your entities. To use it, change the MyDatabase class asfollows:@UseMoor(tables: [Todos, Categories])class MyDatabase extends _$MyDatabase {  // we tell the database where to store the data with this constructor  MyDatabase() : super(FlutterQueryExecutor.inDatabaseFolder(path: 'db.sqlite'));  // you should bump this number whenever you change or add a table definition. Migrations  // are covered later in this readme.  @override  int get schemaVersion =&amp;gt; 1; }Congrats, you are now ready to fully use moor and write queries.",
    "url": "https://moor.simonbinder.eu/getting-started/",
    "relUrl": "/getting-started/"
  },
  "4": {
    "id": "4",
    "title": "Home",
    "content": "MoorMoor is an easy to use, reactive persistence library for Flutter apps. Define yourdatabase tables in pure Dart and enjoy a fluent query API, auto-updating streamsand more!Get started nowView on GitHubGetting startedAdding the dependencyFirst, let’s add moor to your project’s pubspec.yaml.At the moment, the current version of moor_flutter is  and the current version of moor_generator is dependencies:  moor_flutter: # use the latest versiondev_dependencies:  moor_generator: # use the latest version  build_runner: We’re going to use the moor_flutter library to specify tables and access the database. Themoor_generator library will take care of generating the necessary code so thelibrary knows what your table structure looks like.Declaring tablesUsing moor, you can model the structure of your tables with simple dart code:import 'package:moor_flutter/moor_flutter.dart';// assuming that your file is called filename.dart. This will give an error at first,// but it's needed for moor to know about the generated codepart 'filename.g.dart'; // this will generate a table called &quot;todos&quot; for us. The rows of that table will// be represented by a class called &quot;Todo&quot;.class Todos extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get title =&amp;gt; text().withLength(min: 6, max: 32)();  TextColumn get content =&amp;gt; text().named('body')();  IntColumn get category =&amp;gt; integer().nullable()();}// This will make moor generate a class called &quot;Category&quot; to represent a row in this table.// By default, &quot;Categorie&quot; would have been used because it only strips away the trailing &quot;s&quot;// in the table name.@DataClassName(&quot;Category&quot;)class Categories extends Table {    IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get description =&amp;gt; text()();}// this annotation tells moor to prepare a database class that uses both of the// tables we just defined. We'll see how to use that database class in a moment.@UseMoor(tables: [Todos, Categories])class MyDatabase {  }⚠️ Note: The column definitions, the table name and the primary key must be known atcompile time. For column definitions and the primary key, the function must use the =&amp;gt;operator and can’t contain anything more than what’s included in the documentation and theexamples. Otherwise, the generator won’t be able to know what’s going on.Generating the codeMoor integrates with Dart’s build system, so you can generate all the code needed with flutter packages pub run build_runner build. If you want to continously rebuild the generated codewhever you change your code, run flutter packages pub run build_runner watch instead.After running either command once, the moor generator will have created a class for yourdatabase and data classes for your entities. To use it, change the MyDatabase class asfollows:@UseMoor(tables: [Todos, Categories])class MyDatabase extends _$MyDatabase {  // we tell the database where to store the data with this constructor  MyDatabase() : super(FlutterQueryExecutor.inDatabaseFolder(path: 'db.sqlite'));  // you should bump this number whenever you change or add a table definition. Migrations  // are covered later in this readme.  @override  int get schemaVersion =&amp;gt; 1; }You can ignore the schemaVersion at the moment, the important part is that you cannow run your queries with fluent Dart codeWriting queriesTODO-ListThere are some sql features like group by statements which aren’t natively supported by moor yet.However, as moor supports custom sql queries, there are easyworkarounds for most entries on this list. Custom queries work well together with the regular api,as they integrate with stream queries and automatic result parsing.Limitations (at the moment)These aren’t sorted by priority. If you have more ideas or want some features happening soon,let me know by creating an issue!  No group by, count, or window functions  Support other platforms:          VM apps      Web apps via AlaSQL or a different engine?        References (can be expressed via custom constraints, see issue #14)  When inserts / updates fail due to invalid data, explain why that happened",
    "url": "https://moor.simonbinder.eu/",
    "relUrl": "/"
  },
  "5": {
    "id": "5",
    "title": "Table joins",
    "content": "JoinsMoor supports sql joins to write queries that operate on more than one table. To use that feature, starta select regular select statement with select(table) and then add a list of joins using .join(). Forinner and left outer joins, a ON expression needs to be specified. Here’s an example using the tablesdefined in the example.// we define a data class to contain both a todo entry and the associated categoryclass EntryWithCategory {  EntryWithCategory(this.entry, this.category);  final TodoEntry entry;  final Category category;}// in the database class, we can then load the category for each entryStream&amp;lt;List&amp;lt;EntryWithCategory&amp;gt;&amp;gt; entriesWithCategory() {  final query = select(todos).join([    leftOuterJoin(categories, categories.id.equalsExp(todos.category)),  ]);  // see next section on how to parse the result}Parsing resultsCalling get() or watch on a select statement with join returns a Future or Stream ofList&amp;lt;TypedResult&amp;gt; respectively. Each TypedResult represents a row from which data can be read. It contains a rawData getter to obtain the raw row. But more importantly, thereadTable method can be used to read a data class from a table.In the example query above, we can read the todo entry and the category from each row like this:return query.watch().map((rows) {  return rows.map((row) {    return EntryWithCategory(      row.readTable(todos),      row.readTable(categories),    );  }).toList();});Note: readTable returns null when an entity is not present in the row. For instance, todo entriesmight not be in any category. In that case, row.readTable(categories) returns null.AliasesSometimes, a query references a table more than once. Consider the following example to store saved routes for anavigation system:class GeoPoints extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get name =&amp;gt; text()();  TextColumn get latitude =&amp;gt; text()();  TextColumn get longitude =&amp;gt; text()();}class Routes extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get name =&amp;gt; text()();  // contains the id for the start and destination geopoint.  IntColumn get start =&amp;gt; integer()();  IntColumn get destination =&amp;gt; integer()();}Now, let’s say we wanted to also load the start and destination GeoPoint object for each route. We’d have to usea join on the geo-points table twice: For the start and destination point. To express that in a query, aliasescan be used:class RouteWithPoints {  final Route route;  final GeoPoint start;  final GeoPoint destination;  RouteWithPoints({this.route, this.start, this.destination});}// inside the database class:Future&amp;lt;List&amp;lt;RouteWithPoints&amp;gt;&amp;gt; loadRoutes() async {  // create aliases for the geoPoints table so that we can reference it twice  final start = alias(geoPoints, 's');  final destination = alias(geoPoints, 'd');   final rows = await select(routes).join([    innerJoin(start, start.id.equalsExp(routes.start)),    innerJoin(destination, destination.id.equalsExp(routes.destination)),  ]).get();  return rows.map((resultRow) {    return RouteWithPoints(      route: resultRow.readTable(routes),      start: resultRow.readTable(start),      destination: resultRow.readTable(destination),    );  }).toList();}The generated statement then looks like this:SELECT     routes.id, routes.name, routes.start, routes.destination,    s.id, s.name, s.latitude, s.longitude,    d.id, d.name, d.latitude, d.longitude FROM routes     INNER JOIN geo_points s ON s.id = routes.start    INNER JOIN geo_points d ON d.id = routes.destination",
    "url": "https://moor.simonbinder.eu/queries/joins",
    "relUrl": "/queries/joins"
  },
  "6": {
    "id": "6",
    "title": "Migrations",
    "content": "MigrationsMoor provides a migration API that can be used to gradually apply schema changes after bumpingthe schemaVersion getter inside the Database class. To use it, override the migrationgetter. Here’s an example: Let’s say you wanted to add a due date to your todo entries:class Todos extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get title =&amp;gt; text().withLength(min: 6, max: 10)();  TextColumn get content =&amp;gt; text().named('body')();  IntColumn get category =&amp;gt; integer().nullable()();  DateTimeColumn get dueDate =&amp;gt; dateTime().nullable()(); // we just added this column}We can now change the database class like this:  @override  int get schemaVersion =&amp;gt; 2; // bump because the tables have changed  @override  MigrationStrategy get migration =&amp;gt; MigrationStrategy(    onCreate: (Migrator m) {      return m.createAllTables();    },    onUpgrade: (Migrator m, int from, int to) async {      if (from == 1) {        // we added the dueDate property in the change from version 1        await m.addColumn(todos, todos.dueDate);      }    }  );  // rest of class can stay the sameYou can also add individual tables or drop them. You can’t use the high-level query API inmigrations. If you need to use it, please specify the onFinished method on the MigrationStrategy. It will be called after a migration happened and it’s safe to call methodson your database from inside that method.",
    "url": "https://moor.simonbinder.eu/migrations/",
    "relUrl": "/migrations/"
  },
  "7": {
    "id": "7",
    "title": "Transactions",
    "content": "TransactionsMoor has support for transactions and allows multiple queries to run atomically.To begin a transaction, call the transaction method on your database or a DAO.It takes a function as an argument that will be run on the transaction. In thefollowing example, which deals with deleting a category, we move all todo entriesin that category back to the default category:Future deleteCategory(Category category) {  return transaction((t) async {    // first, move the affected todo entries back to the default category    await t.customUpdate(      'UPDATE todos SET category = NULL WHERE category = ?',      updates: {todos},      variables: [Variable.withInt(category.id)],    );    // then, delete the category    await t.delete(categories).delete(category);  });}⚠️ GotchasThere are a couple of things that should be kept in mind when working with transactions:  Await all calls: All queries inside the transaction must be await-ed. The transaction  will complete when the inner method completes. Without await, some queries might be operating  on the transaction after it has been closed!  Don’t run calls on your database: Inside a transaction function, all queries must  be on the transaction itself.    await transaction((t) async {  // BAD - this will run on the database itself!  await delete(categories).delete(category);});await transaction((t) async {  // GOOD!  await t.delete(categories).delete(category);});        The reason behind this is that no calls can operate on the database while it’s in a transaction,  they will run after the transaction has completed. When the completion of the transaction can only  happen after a call to the database completes, as in the fist example, the database will reach a  dead lock!  Transactions and query streamsQuery streams that have been created outside a transaction work nicely together withupdates made in a transaction: All changes to tables will only be reported after thetransaction completes. Updates inside a transaction don’t have an immediate effect onstreams.However, streams cannot be created inside transactions! The reason behind that decisionis that it’s unclear what should happen to the stream after the transaction completes.Should the stream complete as well? Begin to the updated data outside the transaction?To not make things confusing here, this is forbidden.",
    "url": "https://moor.simonbinder.eu/transactions",
    "relUrl": "/transactions"
  },
  "8": {
    "id": "8",
    "title": "Writing queries",
    "content": "Note: This assumes that you already have your database class ready. Follow the [instructions][getting-started] over here on how to do that.Writing queriesThe examples here use the tables defined [here][getting-started].For each table you’ve specified in the @UseMoor annotation on your database class,a corresponding getter for a table will be generated. That getter can be used torun statements:// inside the database class, the `todos` getter has been created by moor.// loads all todo entriesFuture&amp;lt;List&amp;lt;Todo&amp;gt;&amp;gt; get allTodoEntries =&amp;gt; select(todos).get();// watches all todo entries in a given category. The stream will automatically// emit new items whenever the underlying data changes.Stream&amp;lt;List&amp;lt;TodoEntry&amp;gt;&amp;gt; watchEntriesInCategory(Category c) {  return (select(todos)..where((t) =&amp;gt; t.category.equals(c.id))).watch();}Select statementsYou can create select statements by starting them with select(tableName), where the table nameis a field generated for you by moor. Each table used in a database will have a matching fieldto run queries against. Any query can be run once with get() or be turned into an auto-updatingstream using watch().WhereYou can apply filters to a query by calling where(). The where method takes a function thatshould map the given table to an Expression of boolean. A common way to create such expressionis by using equals on expressions. Integer columns can also be compared with isBiggerThanand isSmallerThan. You can compose expressions using and(a, b), or(a, b) and not(a).LimitYou can limit the amount of results returned by calling limit on queries. The method acceptsthe amount of rows to return and an optional offset.OrderingYou can use the orderBy method on the select statement. It expects a list of functions that extract the individualordering terms from the table.Future&amp;lt;List&amp;lt;TodoEntry&amp;gt;&amp;gt; sortEntriesAlphabetically() {  return (select(todos)..orderBy([(t) =&amp;gt; OrderingTerm(expression: t.title)])).get();}You can also reverse the order by setting the mode property of the OrderingTerm toOrderingMode.desc.Updates and deletesYou can use the generated row class to update individual fields of any row:Future moveImportantTasksIntoCategory(Category target) {  // use update(...).write when you have a custom where clause and want to update  // only the columns that you specify (here, only &quot;category&quot; will be updated, the  // title and description of the rows affected will be left unchanged).  // Notice that you can't set fields back to null with this method.  return (update(todos)      ..where((t) =&amp;gt; t.title.like('%Important%'))    ).write(TodoEntry(      category: target.id    ),  );}Future update(TodoEntry entry) {  // using replace will update all fields from the entry that are not marked as a primary key.  // it will also make sure that only the entry with the same primary key will be updated.  // Here, this means that the row that has the same id as entry will be updated to reflect  // the entry's title, content and category. Unlike write, this supports setting columns back  // to null. As it set's its where clause automatically, it can not be used together with where.  return update(todos).replace(entry);}Future feelingLazy() {  // delete the oldest nine entries  return (delete(todos)..where((t) =&amp;gt; t.id.isSmallerThanValue(10))).go();}⚠️ Caution: If you don’t explicitly add a where clause on updates or deletes, the statement will affect all rows in the table!InsertsYou can very easily insert any valid object into tables:// returns the generated idFuture&amp;lt;int&amp;gt; addTodoEntry(Todo entry) {  return into(todos).insert(entry);}All row classes generated will have a constructor that can be used to create objects:addTodoEntry(  Todo(    title: 'Important task',    content: 'Refactor persistence code',  ),);If a column is nullable or has a default value (this includes auto-increments), the fieldcan be omitted. All other fields must be set and non-null. The insert method will throwotherwise.            [getting-started]: {{ site.common_links.getting_started      absolute_url }}      ",
    "url": "https://moor.simonbinder.eu/queries/",
    "relUrl": "/queries/"
  }
}
